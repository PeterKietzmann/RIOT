- RDM: rdm-random.md
- Title: Random architecture
- Author: Peter Kietzmann
- Status: draft
- Type: Design
- Created: February 2019

## Abstract

This memo proposes an update to the current [random](https://riot-os.org/api/group__sys__random.html) architecture in RIOT. It is heavily influenced by the NIST Special Publication 800-90A (4).

## Status

This initial version of the RDM presents planned changes to the random infrastructure and acts as a place to (i) find consensus about these changes in the community and
(ii) document the design goals of the re-work. The content of this document is licensed with a Creative Commons CC-BY-SA license.

## Terminology

This memo uses the [RFC2119](https://www.ietf.org/rfc/rfc2119.txt) terminology
and the following acronyms:

- PUF: Physical unclonable function
- HWRNG: Hardware random number generator
- PRNG: Pseudo-random number generator
- NVM: Non-volatile memory

# 0. PRNG Attack Interfaces
- Any method of distinguishing between PRNG outputs and random is an attack
- In practice: learn, predict (backtrack) or control future outputs

## w/ device access
- inject/run malicious code
- access internal states/keys in memory (debugger?)
- change operating conditions
(temperature, humidity, electric field, power supply)

## w/o device access
(analytic attack, state comprise)

- follow network traffic
- request RNG data (nonces, salts, keys, ...)


# 1. Introduction
The random module provides a common interface to the software PRNG. This sovereign task requires reliable entropy sources for PRNG seeding as well as mechanisms to report inadequate sources to the application programmer. In the following of this document we propose a collection of changes to improve the current situation.

# 2. Problem Statement

- The `random` module restricts usage to one generator at a time. Thereby, no distinction is made
between fast lightweight and complex but secure mechanisms, although a variety is implemented in RIOT.

- The `random` module is seeded by `auto_init` which uses the `random_init(uint32_t seed)`. Even with full entropy, 32-bit is not enough for a secure PRNG.

- The `random` module is seeded with a value derived from a **single** entropy, even when multiple sources are available on a platform.

- The `random` module lacks an interface that informs about defects, e.g., lack of entropy during seeding.


# 3. Related Work

- NIST SP 800-90A recommends periodic reseeding of a generator to reduce security risks and
provideprediction resistance for cryptographic applications. Reseeding means to bring in fresh
entropy values to the state of a generator. This mechanism is also implemented in
mbedTLS.

- NIST SP 800-90A recommends to have entropy that is equal to or greater than the security strength of the instantiation.

- Linux `/dev/random` (5), mbedTLS (1), TinyRNG (6) recommend utilization of multiple entropy sources to be robust against seed observation and manipulation.

- NIST SP 800-90A and SP 800-90B (7) recommend mechanisms to be able to report status and to react to internal errors from entropy inputs as well as pseudo-random numbers. Failures might imply defect seeds or failed health tests.



# 4. Solutions

## Random Seed

### Entropy Source
The most common and prevalent sources for entropy on an IoT node include:

- PUF
- HWRNG
- ADC noise
- External devices like Crypto-ICs, radios with RNG, ...
- CPUID
- Deployed key in NVM

.. where the latter two don't provide entropy between two boot processes of a device. The proposed change enables the most reasonable entropy source(s) for a platform to form a seed.

### Entropy Accumulation

The proposed change adds one layer of abstraction to decapsulate entropy gathering and PRNG seeding. Furthermore, it enables entropy accumulation of varying sources, in case one source is defect. A derivation function may be required to generate a seed from from multiple entropy inputs. The idea of entropy gathering initially popped up in [#4294](https://github.com/RIOT-OS/RIOT/pull/4294). An alternative but slightly more heavy-weight implementation can be found in the SSL library mbed TLS (1) which is included in the ARM MBED operation system. The concept was proposed in NIST Special Publication 800-90A.


### Reporting
There are certain situations in which the seed was not generated by a proper entropy source, for example (i) the device does not provide an entropy source, (ii) the entropy bases on the SRAM PUF (3) module which detected a soft-reset or (iii) a health test during runtime fails. In order for an application developer to check for inadequate seeding, this change proposes a seed state that can be read by a simple get function.

## PRNG

### Parallel PRNGs
Some applications require random numbers for simple purposes such as trickle timers whereas others rely on cryptographically secure, high entropy and unpredictable sequences. Both MAY be required in parallel. This document proposes an architecture that allows for parallel PRNGs, which also implies parallel seeding. In order to make the distinction between these generator types clear for the developer, this document proposes a second API next to the existing one, which is suffixed with something like `_secure` and only implements generators that are considered "crypto-safe".

### State Maintenance
A protocol implementation or security application may require to self-seed generator and to self-maintain its state. This document proposes an adoption of the random API in a way that generators can run on an external state as an alternative to the global state that is used by default.

### Reseeding
As stated in NIST SP 800-90A, periodic reseeding of a generator reduces security risks and provides prediction resistance for cryptographic applications. The mechanism should be implemented by the generator. Reseeding requires entropy sources during runtime which will be combined with the internal PRNG state. For that, entropy from an SRAM PUF is not enough, as it only provides entropy for each cold start.

### Reporting and Administrative Information
Similar to [reporting entropy state](#reporting) a PRNG infrastructure holds information such as generator security strength or presence of periodic reseeding (prediction resistance).

### Uninstantiate
An uninstantiate function should zeroizes/erase the internal state of a generator.

### Health Test
For crypto applications, the generator output should be monitored to verify it is not defect. NIST recommends two lightweight health tests for this purpose. This document proposes an optional health test module running on PRNGs. This module should be able to report issues with generators and eventually block generator output.

### Memory
TBD

- incorporate secure memory?
- all generators thread safe?

## Comment on PRNG Wrapper
For the future we MAY implement a feature as proposed in (2). Furthermore, an optional simple and generic health test instantiation would wrap around the PRNG API. This document motivates an optional module on top of PRNG to implement additional logic.


# Acknowledgements

# References
(1) [https://github.com/ARMmbed/mbedtls/blob/development/include/mbedtls/entropy.h](https://github.com/ARMmbed/mbedtls/blob/development/include/mbedtls/entropy.h)

(2) [https://datatracker.ietf.org/doc/draft-irtf-cfrg-randomness-improvements/](https://datatracker.ietf.org/doc/draft-irtf-cfrg-randomness-improvements/)

(3) [https://riot-os.org/api/puf__sram_8h.html](https://riot-os.org/api/puf__sram_8h.html)

(4) [NIST Special Publication 800-90A](https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final)

(5) [Linux Random Number Generator â€“ A New Approach ](http://chronox.de/lrng/doc/lrng.html)

(6) [TinyRNG: A Cryptographic Random NumberGenerator for Wireless Sensors Network Nodes](https://hal.inria.fr/inria-00190971/document)

(7) [NIST Special Publication 800-90B](https://csrc.nist.gov/publications/detail/sp/800-90b/final)

# Revision

- Rev0: initial document

# Contact

The author of this memo can be contacted via email at peter.kietzmann@haw-hamburg.de
